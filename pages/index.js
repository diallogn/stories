import { useState, useEffect, useReducer, useCallback } from 'react';
import Head from 'next/head';
import styles from '../styles/Home.module.css';
import Search from '../components/search';
import List from '../components/list';
import db from '../db';
import axios from 'axios';
import { concat, sortBy } from 'lodash';
import LastSearch from '../components/lastSearch';

export default function Home() {
  const API_BASE = 'https://hn.algolia.com/api/v1';
  const API_SEARCH = '/search';
  const PARAM_SEARCH = 'query=';
  const PARAM_PAGE = 'page=';
  const SORTS = {
    NONE: (list) => list,
    TITLE: (list) => sortBy(list, 'title'),
    AUTHOR: (list) => sortBy(list, 'author'),
    COMMENT: (list) => sortBy(list, 'num_comments').reverse(),
    POINT: (list) => sortBy(list, 'points').reverse(),
  };
  const getUrl = (searchTerm, page) =>
    `${API_BASE}${API_SEARCH}?${PARAM_SEARCH}${searchTerm}&${PARAM_PAGE}${page}`;

  // React asyncronius data
  const getAsyncStories = () => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        // reject()
        resolve({ data: { stories: db.initialStories } });
      }, 2000);
    });
  };
  // useReducer function
  const storiesReducer = (state, action) => {
    switch (action.type) {
      case 'STORIES_FETCH_INIT':
        return {
          ...state,
          isLoading: true,
          isError: false,
        };
      case 'STORIES_FETCH_SUCCESS':
        return {
          ...state,
          isLoading: false,
          isError: false,
          data:
            action.payload.page === 0
              ? action.payload.list
              : state.data.concat(action.payload.list),
          page: action.payload.page,
        };
      case 'STORIES_FETCH_FAILURE':
        return {
          ...state,
          isLoading: false,
          isError: true,
        };
      case 'REMOVE_STORY':
        return {
          ...state,
          data: state.data.filter(
            (story) => action.payload.objectID !== story.objectID
          ),
        };
      default:
        throw new Error();
    }
  };

  // useStates
  const [searchTerm, setSearchTerm] = useState('');
  const [stories, dispatchStories] = useReducer(storiesReducer, {
    data: [],
    page: 0,
    isLoading: false,
    isError: false,
  });
  const [sort, setSort] = useState({
    sortKey: 'NONE',
    isReverse: false,
  });
  const [urls, setUrls] = useState([getUrl(searchTerm, 0)]);

  // useCallback
  const handleFetchStories = useCallback(async () => {
    if (!searchTerm) return;

    dispatchStories({ type: 'STORIES_FETCH_INIT' });
    try {
      const lastUrl = urls[urls.length - 1];
      const result = await axios.get(lastUrl);
      dispatchStories({
        type: 'STORIES_FETCH_SUCCESS',
        payload: {
          list: result.data.hits,
          page: result.data.page,
        },
      });
    } catch {
      dispatchStories({ type: 'STORIES_FETCH_FAILURE' });
    }
  }, [urls]);

  //useEffect
  useEffect(() => {
    handleFetchStories();
  }, [handleFetchStories]);
  // helpers
  const extractSearchTerm = (url) => {
    return url
      .substring(url.lastIndexOf('?') + 1, url.lastIndexOf('&'))
      .replace(PARAM_SEARCH, '');
  };
  // Events handler
  const handleSearch = (searchTerm, page) => {
    const url = getUrl(searchTerm, page);
    setUrls(urls.concat(url));
  };
  const handleMore = () => {
    const lastUrl = urls[urls.length - 1];
    const searchTerm = extractSearchTerm(lastUrl);
    handleSearch(searchTerm, stories.page + 1);
  };
  const handleSearchSubmit = (event) => {
    const url = getUrl(searchTerm, 0);
    setUrls(urls.concat(url));
    event.preventDefault();
  };

  const handleLastSearch = (searchTerm) => {
    setSearchTerm(searchTerm);
    handleSearch(searchTerm, 0);
  };
  //search
  const handleSearchInput = (event) => {
    setSearchTerm(event.target.value);
  };
  // remove story
  const handleRemoveStory = (item) => {
    dispatchStories({
      type: 'REMOVE_STORY',
      payload: item,
    });
  };
  // sort
  const handleSort = (sortKey) => {
    const isReverse = sort.sortedKey === sortKey && !sort.isReverse;
    setSort({ sortKey, isReverse });
  };

  const sortFunction = SORTS[sort.sortKey];
  const sortedList = sort.isReverse
    ? sortFunction(stories.data).reverse()
    : sortFunction(stories.data);

  const getLastSearches = (urls) => urls.slice(-5).map(extractSearchTerm);

  const lastSearchList = getLastSearches(urls);
  return (
    <div className="container">
      <Head>
        <title>{db.title}</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <main className={styles.main}>
        <div className="header">
          <h2 className="headline-primary">{db.title}</h2>
          <Search
            searchTerm={searchTerm}
            onSearch={handleSearchInput}
            onSearchSubmit={handleSearchSubmit}
          />
        </div>
        <div className="lastSearch">
          <LastSearch
            lastSearches={lastSearchList}
            onLastSearch={handleLastSearch}
          />
        </div>
        {stories.data.length !== 0 && (
          <div className="sortButtons">
            <h5 style={{ marginRight: '10px' }}>sorted by: </h5>
            <select onChange={(e) => handleSort(e.target.value)}>
              <option value="TITLE">Title</option>
              <option value="AUTHOR">Author</option>
              <option value="COMMENT">comment</option>
              <option value="POINT">point</option>
            </select>
          </div>
        )}

        <ul>
          {stories.data.length > 0 && (
            <li style={{ display: 'flex' }}>
              <span style={{ fontWeight: 'bold', width: '45%' }}>Title</span>
              <span style={{ fontWeight: 'bold', width: '30%' }}>Author</span>
              <span style={{ fontWeight: 'bold', width: '10%' }}>Comments</span>
              <span style={{ fontWeight: 'bold', width: '10%' }}>Points</span>
              <span style={{ fontWeight: 'bold', width: '5%' }}>Actions</span>
            </li>
          )}
          {stories.isError && (
            <li className={styles.isError}>Something went wrong</li>
          )}
          {stories.isLoading ? (
            <li className={styles.isLoading}>Loading...</li>
          ) : (
            <>
              <List sortedList={sortedList} onRemoveItem={handleRemoveStory} />
              {stories.data.length > 0 && (
                <div className="pagination">
                  <button
                    className="button button-small"
                    type="button"
                    onClick={handleMore}
                  >
                    More
                  </button>
                </div>
              )}
            </>
          )}
        </ul>
      </main>
    </div>
  );
}
